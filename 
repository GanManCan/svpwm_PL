[33mcommit 18290ba70236b05dd29048f290b0bc559c98fb70[m[33m ([m[1;36mHEAD -> [m[1;32mmain[m[33m)[m
Author: GanManCan <mgannon1606@gmail.com>
Date:   Thu Dec 9 20:11:18 2021 -0500

    Simple Sim working for clarke_transform.

[1mdiff --git a/svpwm_PL.srcs/sources_1/new/clarke_transform.vhd b/svpwm_PL.srcs/sources_1/new/clarke_transform.vhd[m
[1mindex c47de25..40bc9df 100644[m
[1m--- a/svpwm_PL.srcs/sources_1/new/clarke_transform.vhd[m
[1m+++ b/svpwm_PL.srcs/sources_1/new/clarke_transform.vhd[m
[36m@@ -93,7 +93,7 @@[m [mbegin[m
 			[m
 				when IDLE =>[m
 					clarke_done <= '0'; [m
[31m-					fp_yb_min_yc <= (OTHERS => '0'); [m
[32m+[m					[32m--fp_yb_min_yc <= (OTHERS => '0');[m[41m [m
 					[m
 					if(clarke_start = '1') then[m
 						-- Lock in y_alpha and y_beta for calculations[m
[36m@@ -101,15 +101,16 @@[m [mbegin[m
 						fp_y_b_hold <= fp_y_b;[m
 						fp_y_c_hold <= fp_y_c; [m
 						[m
[32m+[m						[32m-- Calculate subtraction used for this and next multiplication[m
[32m+[m						[32mfp_yb_min_yc <= resize(fp_y_b- fp_y_c, fp_yb_min_yc);[m
[32m+[m[41m						[m
 						-- Move to next state[m
 						state <= MULT_Y_ALPHA; [m
 						[m
 					end if; --if(clark_starte = 1)[m
 				when MULT_Y_ALPHA =>[m
 					[m
[31m-					-- Calculate subtraction used for this and next multiplication[m
[31m-					fp_yb_min_yc <= resize(fp_y_b_hold - fp_y_c_hold, fp_yb_min_yc); [m
[31m-					[m
[32m+[m[41m					 [m
 					-- Calcualte y_alpha[m
 					fp_y_alpha <= resize(fp_2_3*fp_y_a_hold - fp_1_3*fp_yb_min_yc, fp_y_a_hold);[m
 					[m
[1mdiff --git a/test_benches/clarke_transform_tb.vhd b/test_benches/clarke_transform_tb.vhd[m
[1mindex 3912d51..c22729c 100644[m
[1m--- a/test_benches/clarke_transform_tb.vhd[m
[1m+++ b/test_benches/clarke_transform_tb.vhd[m
[36m@@ -46,6 +46,7 @@[m [marchitecture bench of clarke_transform_tb is[m
   CONSTANT sine_step  : real := 2.0*MATH_PI/100.0; [m
   CONSTANT real_DC_input : real := 200.0;[m
   signal real_sin_a, real_sin_b, real_sin_c, real_rad	: real := 0.0; [m
[32m+[m[32m  signal real_y_alpha, real_y_beta : real := 0.0;[m
 [m
 begin[m
 [m
[36m@@ -85,7 +86,15 @@[m [mbegin[m
 		real_sin_a <= real_DC_input*sin(real_rad);[m
 		real_sin_b <= real_DC_input*sin(real_rad - (2.0*MATH_PI/3.0));[m
 		real_sin_c <= real_DC_input*sin(real_rad - (4.0*MATH_PI/3.0));[m
[31m-	  [m
[32m+[m[41m		[m
[32m+[m		[32mreal_y_alpha <= 2.0*real_sin_a/3.0 - (real_sin_b - real_sin_c)/3.0;[m
[32m+[m		[32mreal_y_beta <= 2.0/SQRT(3.0)*(real_sin_b-real_sin_c);[m
[32m+[m[41m		[m
[32m+[m		[32m-- Code to go from "real" to fixed point input to VHDL block[m
[32m+[m		[32mfp_y_a <= to_sfixed(real_sin_a ,20, -11);[m
[32m+[m		[32mfp_y_b <= to_sfixed(real_sin_b ,20, -11);[m
[32m+[m		[32mfp_y_c <= to_sfixed(real_sin_c ,20, -11);[m
[32m+[m[41m		[m
 		if(real_rad >= (2.0*MATH_PI-sine_step)) then[m
 			real_rad <= 0.0;[m
 		end if; -- if (real_rad >= MATH_PI)[m
